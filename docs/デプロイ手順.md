# デプロイ手順

本ドキュメントでは、Django アプリケーションを AWS ECS にデプロイするための手順について説明します。

## 前提条件

- AWSアカウントへのアクセス権限
- AWS CLIのインストールと設定
- Dockerのインストール
- GitHubリポジトリへのアクセス権限
- Terraform（バージョン1.0.0以上）のインストール

## デプロイ環境

本プロジェクトでは以下の環境を定義しています：

- **開発環境（Development）**: 開発者のローカル環境
- **テスト環境（Test）**: CI/CDパイプラインで自動テストを実行する環境
- **ステージング環境（Staging）**: 本番環境と同等の構成で動作確認を行う環境
- **本番環境（Production）**: エンドユーザーが実際に利用する環境

## デプロイフロー

デプロイは以下のフローで実施されます：

```
開発者のローカル環境
      ↓
GitHub（プルリクエスト）
      ↓
CI/CD（自動テスト）
      ↓
ステージング環境（動作確認）
      ↓
本番環境
```

## Djangoアプリの準備と開発作業フロー

Djangoアプリケーションの開発からデプロイまでの作業フローを以下に示します。

### 1. 開発環境での作業

```bash
# 1. ローカル開発環境のセットアップ
git clone https://github.com/grapeejp/django-ecs-simple-deploy.git
cd django-ecs-simple-deploy

# 2. 仮想環境の作成と有効化
python -m venv venv
source venv/bin/activate  # Windowsの場合: venv\Scripts\activate

# 3. 依存パッケージのインストール
pip install -r requirements.txt

# 4. ローカルでの開発サーバー起動
python app/manage.py runserver

# 5. コードの変更とテスト
python app/manage.py test
```

### 2. Djangoアプリケーションのデプロイ準備

```bash
# 1. 環境変数の設定
cp .env.example .env
# .envファイルを編集して環境変数を設定

# 2. 本番環境用設定の確認
python app/manage.py check --deploy

# 3. 静的ファイルの収集
python app/manage.py collectstatic --noinput

# 4. Dockerイメージのビルドテスト
docker-compose up --build
```

### 3. データベースマイグレーション

本番環境にデプロイする前に、ローカルでマイグレーションファイルを作成し、コミットします。

```bash
# 1. マイグレーションファイルの作成
python app/manage.py makemigrations

# 2. マイグレーションの適用テスト
python app/manage.py migrate

# 3. マイグレーションファイルのコミット
git add app/*/migrations/*.py
git commit -m "Add migrations for deployment"
git push origin feature/your-branch
```

## 手動デプロイ手順

CI/CDパイプラインが整備されるまでの間は、以下の手順で手動デプロイを行います。

### 1. 環境変数の設定

```bash
# AWSアカウント情報
export AWS_ACCOUNT_ID=<あなたのAWSアカウントID>
export AWS_REGION=ap-northeast-1
```

### 2. ECRリポジトリにDockerイメージをプッシュ

```bash
# ECRにログイン
aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com

# M3チップ（ARM64）環境では、明示的にプラットフォームを指定してビルド
docker build --platform=linux/amd64 -t django-ecs-app .
docker tag django-ecs-app:latest $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/django-ecs-app:latest

# ECRにプッシュ
docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/django-ecs-app:latest
```

### 3. Terraformによるインフラストラクチャのデプロイ

```bash
# 環境ディレクトリに移動（例：staging）
cd terraform/environments/staging

# Terraformの初期化
terraform init

# 実行プランの確認
terraform plan -var="image_tag=latest"

# インフラストラクチャのデプロイ
terraform apply -var="image_tag=latest"
```

### 4. デプロイ結果の確認

```bash
# ALBのDNS名を取得
terraform output alb_dns_name

# ECSサービスのステータス確認
aws ecs describe-services \
  --cluster $(terraform output ecs_cluster_name) \
  --services $(terraform output ecs_service_name)
```

取得したDNS名にアクセスして、アプリケーションが正常に動作していることを確認します。

### 5. 本番環境でのデータベースマイグレーション実行

ECSタスクを使用してデータベースマイグレーションを実行します。

```bash
# マイグレーション専用のタスク定義ARNを取得
TASK_DEF_ARN=$(terraform output migration_task_definition_arn)

# マイグレーションタスクを実行
aws ecs run-task \
  --cluster $(terraform output ecs_cluster_name) \
  --task-definition $TASK_DEF_ARN \
  --network-configuration "awsvpcConfiguration={subnets=[$(terraform output private_subnet_ids | tr -d '[]"' | tr ',' ' ')],securityGroups=[$(terraform output security_group_id)]}" \
  --launch-type FARGATE

# タスクの実行状態を確認
aws ecs list-tasks \
  --cluster $(terraform output ecs_cluster_name) \
  --family django-ecs-migration
```

### 6. 静的ファイルのS3アップロード

S3バケットに静的ファイルをアップロードします。

```bash
# 静的ファイルの収集
python app/manage.py collectstatic --noinput

# S3バケット名を取得
S3_BUCKET=$(terraform output static_files_bucket_name)

# S3にアップロード
aws s3 sync app/staticfiles/ s3://$S3_BUCKET/static/ --acl public-read
```

### 7. キャッシュのクリア（必要に応じて）

```bash
# キャッシュクリアタスクを実行（必要に応じて実施）
aws ecs run-task \
  --cluster $(terraform output ecs_cluster_name) \
  --task-definition $(terraform output cache_clear_task_definition_arn) \
  --network-configuration "awsvpcConfiguration={subnets=[$(terraform output private_subnet_ids | tr -d '[]"' | tr ',' ' ')],securityGroups=[$(terraform output security_group_id)]}" \
  --launch-type FARGATE
```

## 自動デプロイ（CI/CD）

GitHub Actionsを使用して自動デプロイを行う場合、以下の流れでデプロイが実行されます。

### 1. GitHub Secretsの設定

GitHubリポジトリの設定ページから以下のSecretを設定します：

- `AWS_ACCESS_KEY_ID`: AWSアクセスキーID
- `AWS_SECRET_ACCESS_KEY`: AWSシークレットアクセスキー
- `AWS_REGION`: AWSリージョン（例：ap-northeast-1）
- `AWS_ACCOUNT_ID`: AWSアカウントID

### 2. ワークフローの実行

- `main`ブランチへのプッシュ: ステージング環境へ自動デプロイ
- リリースタグの作成: 本番環境へ自動デプロイ

## ロールバック手順

デプロイに問題が発生した場合のロールバック手順です。

### 1. 前バージョンのイメージタグを確認

```bash
aws ecr describe-images \
  --repository-name django-ecs-app \
  --query 'imageDetails[*].[imageTags,imagePushedAt]' \
  --output text | sort -k 2
```

### 2. 前バージョンのイメージを使用してTerraformを再適用

```bash
# 環境ディレクトリに移動（例：staging）
cd terraform/environments/staging

# 前バージョンのイメージタグを指定して適用
terraform apply -var="image_tag=<前バージョンのタグ>"
```

### 3. ロールバック結果の確認

ALBのDNS名にアクセスして、アプリケーションが正常に動作していることを確認します。

### 4. データベースのロールバック（必要な場合）

マイグレーションによるデータベース変更をロールバックする必要がある場合は、以下の手順で実行します。

```bash
# マイグレーションロールバック用のタスクを実行
aws ecs run-task \
  --cluster $(terraform output ecs_cluster_name) \
  --task-definition $(terraform output migration_task_definition_arn) \
  --network-configuration "awsvpcConfiguration={subnets=[$(terraform output private_subnet_ids | tr -d '[]"' | tr ',' ' ')],securityGroups=[$(terraform output security_group_id)]}" \
  --launch-type FARGATE \
  --overrides '{"containerOverrides": [{"name": "django-app", "command": ["python", "manage.py", "migrate", "app_name", "0001_previous_migration"]}]}'
```

## トラブルシューティング

### ECSサービスのデプロイに失敗する場合

1. ECSサービスイベントを確認
   ```bash
   aws ecs describe-services \
     --cluster $(terraform output ecs_cluster_name) \
     --services $(terraform output ecs_service_name) \
     --query 'services[0].events'
   ```

2. タスク定義の問題を確認
   ```bash
   aws ecs describe-task-definition \
     --task-definition $(terraform output task_definition_family)
   ```

3. CloudWatch Logsでコンテナログを確認
   ```bash
   aws logs get-log-events \
     --log-group-name /ecs/django-ecs-app \
     --log-stream-name <ログストリーム名>
   ```

### ヘルスチェックに失敗する場合

1. ターゲットグループのヘルスチェック設定を確認
   ```bash
   aws elbv2 describe-target-groups \
     --target-group-arn $(terraform output target_group_arn)
   ```

2. セキュリティグループの設定を確認
   ```bash
   aws ec2 describe-security-groups \
     --group-ids $(terraform output security_group_id)
   ```

3. アプリケーションのヘルスチェックエンドポイントが正常に応答するか確認

### Djangoアプリケーションのエラーをデバッグする場合

1. デバッグモードで一時的にECSタスクを実行
   ```bash
   aws ecs run-task \
     --cluster $(terraform output ecs_cluster_name) \
     --task-definition $(terraform output task_definition_family) \
     --network-configuration "awsvpcConfiguration={subnets=[$(terraform output private_subnet_ids | tr -d '[]"' | tr ',' ' ')],securityGroups=[$(terraform output security_group_id)]}" \
     --launch-type FARGATE \
     --overrides '{"containerOverrides": [{"name": "django-app", "environment": [{"name": "DEBUG", "value": "True"}]}]}'
   ```

2. Djangoのエラーページが表示されるか確認（デバッグモード有効時のみ）

3. リクエスト処理のトレースログを確認
   ```bash
   aws logs get-log-events \
     --log-group-name /ecs/django-ecs-app \
     --log-stream-name <ログストリーム名> \
     --filter-pattern "ERROR"
   ```

### Terraformの状態ファイル（terraform.tfstate）が破損した場合

1. 状態ファイルのバックアップを確認（S3バックエンドを使用している場合）
   ```bash
   aws s3 ls s3://<バケット名>/terraform/state/
   ```

2. 最新のバックアップから状態を復元
   ```bash
   aws s3 cp s3://<バケット名>/terraform/state/<最新のバックアップ> terraform.tfstate
   ```

3. 状態を再同期
   ```bash
   terraform refresh
   ``` 